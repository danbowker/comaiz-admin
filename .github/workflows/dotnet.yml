name: .NET
on:
  workflow_dispatch:
  push:
    branches: ["master"]
    paths-ignore:
      - 'powershell/**'
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
  pull_request:
    branches: ["master"]
    paths-ignore:
      - 'powershell/**'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Generate version information
        id: version
        run: |
          # Fetch all tags to ensure git describe works correctly
          git fetch --tags --force || true
          
          # Generate version string using git describe
          # For tagged commits: v1.2.3
          # For other commits: 1.2.3-next.4+gabcdef (if tag exists) or 0.0.0-dev.123+gabcdef (no tags)
          if git describe --tags --exact-match 2>/dev/null; then
            # This is a tagged release
            VERSION=$(git describe --tags --exact-match | sed 's/^v//')
          elif git describe --tags --long 2>/dev/null; then
            # There are previous tags
            DESCRIBE=$(git describe --tags --long)
            TAG=$(echo $DESCRIBE | sed 's/\([^-]*\)-\([0-9]*\)-g\(.*\)/\1/')
            COMMITS=$(echo $DESCRIBE | sed 's/\([^-]*\)-\([0-9]*\)-g\(.*\)/\2/')
            SHA=$(echo $DESCRIBE | sed 's/\([^-]*\)-\([0-9]*\)-g\(.*\)/\3/')
            # Remove 'v' prefix if present for the base version
            TAG_NUM=$(echo $TAG | sed 's/^v//')
            VERSION="${TAG_NUM}-next.${COMMITS}+g${SHA}"
          else
            # No tags exist yet
            COMMITS=$(git rev-list --count HEAD)
            SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0-dev.${COMMITS}+g${SHA}"
          fi
          
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"
      - name: Install frontend dependencies
        run: cd frontend && npm ci
      - name: Create version.json
        run: |
          mkdir -p frontend/public
          cat > frontend/public/version.json << EOF
          {
            "version": "${{ steps.version.outputs.VERSION }}",
            "commit": "${{ github.sha }}",
            "buildTime": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "branch": "${{ github.ref_name }}"
          }
          EOF
          cat frontend/public/version.json
      - name: Build frontend
        env:
          REACT_APP_VERSION: ${{ steps.version.outputs.VERSION }}
        run: cd frontend && npm run build
      - name: Restore dependencies
        run: dotnet restore
      - name: Build
        run: dotnet build --no-restore
      - name: Test
        run: dotnet test --no-build --verbosity normal
      - name: Install Playwright browsers
        run: cd frontend && npx playwright install --with-deps chromium
      - name: Create .env.local for E2E tests
        run: |
          cd frontend
          echo "REACT_APP_API_URL=https://localhost:7057/api" > .env.local
      - name: Run E2E tests
        env:
          CI: true
          PLAYWRIGHT_BASE_URL: http://localhost:3000
        run: |
          # Start backend in background
          cd comaiz.api
          ASPNETCORE_ENVIRONMENT=Development dotnet run --no-build > backend.log 2>&1 &
          BACKEND_PID=$!
          cd ..
          
          # Wait for backend to be ready
          echo "Waiting for backend to start..."
          for i in {1..30}; do
            if curl -k -s -f https://localhost:7057/health > /dev/null 2>&1; then
              echo "Backend is ready!"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done
          
          # Build and serve frontend
          cd frontend
          # Use serve to host the built frontend
          npm install -g serve
          serve -s build -l 3000 > frontend.log 2>&1 &
          FRONTEND_PID=$!
          
          # Wait for frontend to be ready
          echo "Waiting for frontend to start..."
          for i in {1..30}; do
            if curl -s -f http://localhost:3000 > /dev/null 2>&1; then
              echo "Frontend is ready!"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done
          
          # Run E2E tests
          npx playwright test || E2E_FAILED=1
          
          # Cleanup
          kill $BACKEND_PID $FRONTEND_PID || true
          
          # Show logs if tests failed
          if [ "$E2E_FAILED" = "1" ]; then
            echo "=== Backend Logs ==="
            cat ../comaiz.api/backend.log || true
            echo "=== Frontend Logs ==="
            cat frontend.log || true
            exit 1
          fi
      - name: Upload Playwright report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: frontend/playwright-report/
          retention-days: 30
      - name: Upload E2E screenshots
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-screenshots
          path: frontend/screenshots/
          retention-days: 30
      - name: Build Docker image
        run: |
          docker build \
            --build-arg VERSION="${{ steps.version.outputs.VERSION }}" \
            --build-arg COMMIT="${{ github.sha }}" \
            --build-arg BUILD_TIME="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
            --build-arg BRANCH="${{ github.ref_name }}" \
            -t ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }} \
            .
      - name: Log in to GitHub Container Registry
        run: echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Push Docker image
        if: github.event_name != 'pull_request'
        run: docker push ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
      - name: Tag and push version and latest
        if: startsWith(github.ref, 'refs/tags/v')
        run: |
          VERSION_TAG=${GITHUB_REF#refs/tags/}
          docker tag ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }} ghcr.io/${{ github.repository }}/comaiz-admin:${VERSION_TAG}
          docker tag ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }} ghcr.io/${{ github.repository }}/comaiz-admin:latest
          docker push ghcr.io/${{ github.repository }}/comaiz-admin:${VERSION_TAG}
          docker push ghcr.io/${{ github.repository }}/comaiz-admin:latest

  deploy-staging:
    needs: build
    if: (github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: read
    environment:
      name: staging
      url: https://staging.comaiz.co.uk

    steps:
      - name: Deploy to staging
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          STAGING_CONNECTION_STRING: ${{ secrets.STAGING_CONNECTION_STRING }}
          JWT_AUTHORITY: ${{ secrets.JWT_AUTHORITY }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
        run: |
          echo "$SSH_PRIVATE_KEY" > private_key
          chmod 600 private_key
          # Create env file with secrets
          cat > deploy.env << ENVEOF
          JWT_AUTHORITY=${JWT_AUTHORITY}
          JWT_AUDIENCE=${JWT_AUDIENCE}
          STAGING_CONNECTION_STRING=${STAGING_CONNECTION_STRING}
          ENVEOF
          # Transfer env file to remote server
          scp -o StrictHostKeyChecking=no -i private_key deploy.env $SERVER_USER@$SERVER_IP:/tmp/deploy-staging.env
          rm -f deploy.env
          # Execute deployment with env file
          ssh -o StrictHostKeyChecking=no -i private_key $SERVER_USER@$SERVER_IP << 'EOF'
            source /tmp/deploy-staging.env
            docker pull ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
            docker stop comaiz-admin-staging || true
            docker rm comaiz-admin-staging || true
            docker run -d \
              --name comaiz-admin-staging \
              -p 8081:8080 \
              -e "Jwt__Authority=${JWT_AUTHORITY}" \
              -e "Jwt__Audience=${JWT_AUDIENCE}" \
              -e "ConnectionStrings__PostgresSQL=${STAGING_CONNECTION_STRING}" \
              ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
            rm -f /tmp/deploy-staging.env
          EOF
          rm -f private_key

  deploy-production:
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    permissions:
      contents: read
    environment:
      name: production
      url: https://comaiz.co.uk

    steps:
      - name: Deploy to production
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          PRODUCTION_CONNECTION_STRING: ${{ secrets.PRODUCTION_CONNECTION_STRING }}
          JWT_AUTHORITY: ${{ secrets.JWT_AUTHORITY }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
        run: |
          echo "$SSH_PRIVATE_KEY" > private_key
          chmod 600 private_key
          # Create env file with secrets
          cat > deploy.env << ENVEOF
          JWT_AUTHORITY=${JWT_AUTHORITY}
          JWT_AUDIENCE=${JWT_AUDIENCE}
          PRODUCTION_CONNECTION_STRING=${PRODUCTION_CONNECTION_STRING}
          ENVEOF
          # Transfer env file to remote server
          scp -o StrictHostKeyChecking=no -i private_key deploy.env $SERVER_USER@$SERVER_IP:/tmp/deploy-production.env
          rm -f deploy.env
          # Execute deployment with env file
          ssh -o StrictHostKeyChecking=no -i private_key $SERVER_USER@$SERVER_IP << 'EOF'
            source /tmp/deploy-production.env
            docker pull ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
            docker stop comaiz-admin || true
            docker rm comaiz-admin || true
            docker run -d \
              --name comaiz-admin \
              -p 8080:8080 \
              -e "Jwt__Authority=${JWT_AUTHORITY}" \
              -e "Jwt__Audience=${JWT_AUDIENCE}" \
              -e "ConnectionStrings__PostgresSQL=${PRODUCTION_CONNECTION_STRING}" \
              ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
            rm -f /tmp/deploy-production.env
          EOF
          rm -f private_key
