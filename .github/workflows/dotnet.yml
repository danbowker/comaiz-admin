name: .NET
on:
  workflow_dispatch:
  push:
    branches: ["master"]
    paths-ignore:
      - 'powershell/**'
  pull_request:
    branches: ["master"]
    paths-ignore:
      - 'powershell/**'
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Generate version information
        id: version
        run: |
          # Fetch all tags to ensure git describe works correctly
          git fetch --tags --force || true
          
          # Generate version string using git describe
          # For tagged commits: v1.2.3
          # For other commits: 1.2.3-next.4+gabcdef (if tag exists) or 0.0.0-dev.123+gabcdef (no tags)
          if git describe --tags --exact-match 2>/dev/null; then
            # This is a tagged release
            VERSION=$(git describe --tags --exact-match | sed 's/^v//')
          elif git describe --tags --long 2>/dev/null; then
            # There are previous tags
            DESCRIBE=$(git describe --tags --long)
            TAG=$(echo $DESCRIBE | sed 's/\([^-]*\)-\([0-9]*\)-g\(.*\)/\1/')
            COMMITS=$(echo $DESCRIBE | sed 's/\([^-]*\)-\([0-9]*\)-g\(.*\)/\2/')
            SHA=$(echo $DESCRIBE | sed 's/\([^-]*\)-\([0-9]*\)-g\(.*\)/\3/')
            # Remove 'v' prefix if present for the base version
            TAG_NUM=$(echo $TAG | sed 's/^v//')
            VERSION="${TAG_NUM}-next.${COMMITS}+g${SHA}"
          else
            # No tags exist yet
            COMMITS=$(git rev-list --count HEAD)
            SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0-dev.${COMMITS}+g${SHA}"
          fi
          
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"
      - name: Install frontend dependencies
        run: cd frontend && npm ci
      - name: Create version.json
        run: |
          mkdir -p frontend/public
          cat > frontend/public/version.json << EOF
          {
            "version": "${{ steps.version.outputs.VERSION }}",
            "commit": "${{ github.sha }}",
            "buildTime": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "branch": "${{ github.ref_name }}"
          }
          EOF
          cat frontend/public/version.json
      - name: Build frontend
        env:
          REACT_APP_VERSION: ${{ steps.version.outputs.VERSION }}
        run: cd frontend && npm run build
      - name: Restore dependencies
        run: dotnet restore
      - name: Build
        run: dotnet build --no-restore
      - name: Test
        run: dotnet test --no-build --verbosity normal
      - name: Build Docker image
        run: docker build -t ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }} .
      - name: Log in to GitHub Container Registry
        run: echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Push Docker image
        if: github.event_name != 'pull_request'
        run: docker push ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
      - name: Tag and push latest
        if: github.event_name == 'release'
        run: |
          docker tag ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }} ghcr.io/${{ github.repository }}/comaiz-admin:latest
          docker push ghcr.io/${{ github.repository }}/comaiz-admin:latest

  deploy-staging:
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    environment:
      name: staging
      url: https://staging.comaiz.co.uk

    steps:
      - name: Deploy to staging
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          STAGING_CONNECTION_STRING: ${{ secrets.STAGING_CONNECTION_STRING }}
          JWT_AUTHORITY: ${{ secrets.JWT_AUTHORITY }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
        run: |
          echo "$SSH_PRIVATE_KEY" > private_key
          chmod 600 private_key
          # Create env file with secrets
          cat > deploy.env << ENVEOF
          JWT_AUTHORITY=${JWT_AUTHORITY}
          JWT_AUDIENCE=${JWT_AUDIENCE}
          STAGING_CONNECTION_STRING=${STAGING_CONNECTION_STRING}
          ENVEOF
          # Transfer env file to remote server
          scp -o StrictHostKeyChecking=no -i private_key deploy.env $SERVER_USER@$SERVER_IP:/tmp/deploy-staging.env
          rm -f deploy.env
          # Execute deployment with env file
          ssh -o StrictHostKeyChecking=no -i private_key $SERVER_USER@$SERVER_IP << 'EOF'
            source /tmp/deploy-staging.env
            docker pull ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
            docker stop comaiz-admin-staging || true
            docker rm comaiz-admin-staging || true
            docker run -d \
              --name comaiz-admin-staging \
              -p 8081:8080 \
              -e "Jwt__Authority=${JWT_AUTHORITY}" \
              -e "Jwt__Audience=${JWT_AUDIENCE}" \
              -e "ConnectionStrings__PostgresSQL=${STAGING_CONNECTION_STRING}" \
              ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
            rm -f /tmp/deploy-staging.env
          EOF
          rm -f private_key

  deploy-production:
    needs: build
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    environment:
      name: production
      url: https://comaiz.co.uk

    steps:
      - name: Deploy to production
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          PRODUCTION_CONNECTION_STRING: ${{ secrets.PRODUCTION_CONNECTION_STRING }}
          JWT_AUTHORITY: ${{ secrets.JWT_AUTHORITY }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
        run: |
          echo "$SSH_PRIVATE_KEY" > private_key
          chmod 600 private_key
          # Create env file with secrets
          cat > deploy.env << ENVEOF
          JWT_AUTHORITY=${JWT_AUTHORITY}
          JWT_AUDIENCE=${JWT_AUDIENCE}
          PRODUCTION_CONNECTION_STRING=${PRODUCTION_CONNECTION_STRING}
          ENVEOF
          # Transfer env file to remote server
          scp -o StrictHostKeyChecking=no -i private_key deploy.env $SERVER_USER@$SERVER_IP:/tmp/deploy-production.env
          rm -f deploy.env
          # Execute deployment with env file
          ssh -o StrictHostKeyChecking=no -i private_key $SERVER_USER@$SERVER_IP << 'EOF'
            source /tmp/deploy-production.env
            docker pull ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
            docker stop comaiz-admin || true
            docker rm comaiz-admin || true
            docker run -d \
              --name comaiz-admin \
              -p 8080:8080 \
              -e "Jwt__Authority=${JWT_AUTHORITY}" \
              -e "Jwt__Audience=${JWT_AUDIENCE}" \
              -e "ConnectionStrings__PostgresSQL=${PRODUCTION_CONNECTION_STRING}" \
              ghcr.io/${{ github.repository }}/comaiz-admin:${{ github.sha }}
            rm -f /tmp/deploy-production.env
          EOF
          rm -f private_key
